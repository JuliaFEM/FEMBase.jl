<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fields · FEMBase</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FEMBase</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="fields.html">Fields</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Accessing-fields-1">Accessing fields</a></li><li class="toplevel"><a class="toctext" href="#Continuous-fields-1">Continuous fields</a></li><li class="toplevel"><a class="toctext" href="#Dictionary-fields-1">Dictionary fields</a></li><li class="toplevel"><a class="toctext" href="#Using-common-constructor-field-1">Using common constructor <code>field</code></a></li><li class="toplevel"><a class="toctext" href="#Developing-new-fields-1">Developing new fields</a></li></ul></li><li><a class="toctext" href="basis.html">Basis functions</a></li><li><a class="toctext" href="developing.html">Developing</a></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="fields.html">Fields</a></li></ul><a class="edit-page" href="https://github.com/JuliaFEM/FEMBase.jl/blob/master/docs/src/fields.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Fields</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-julia">using FEMBase</code></pre><p>From the beginning a clear concept: &quot;everything is a field&quot;. We think that constant is just a special case of field which does not vary in temporal and spatial direction. Fields can vary in spatial direction (constant or variable) and in temporal direction (time variant and in-variant).</p><p>From here we can deduct for types of (discrete) fields:</p><ul><li><p>discrete, constant, time invariant (DCTI)</p></li><li><p>discrete, variable, time invariant (DVTI)</p></li><li><p>discrete, constant, time variant (DCTV)</p></li><li><p>discrete, variable, time variant (DVTV)</p></li></ul><p>Field itself can be anything. However, usually either scalar, vector or tensor (matrix).</p><h1><a class="nav-anchor" id="Creating-fields-1" href="#Creating-fields-1">Creating fields</a></h1><p>For discrete fields that are varying in spatial direction, value for each discrete point is defined using NTuple. The order of points is implicitly assumed to be same than node ordering in ABAQUS. Usual use case for variable field is that the field is interpolated to the element volume using interpolation polynomials, i.e. <span>$u(\xi) = u_i N_i(\xi)$</span>, where <span>$N_i$</span> is the basis function for that node and <span>$u_i$</span> is the discrete value.</p><p>For example, <code>(1, 2, 3, 4)</code> is a scalar field having length of 4 and <code>([1,2],[2,3],[3,4],[4,5])</code> is a vector field having length of 4.</p><p>For fields that are varying in temporal direction, <code>time =&gt; value</code> syntax is used. The first item in pair is time and second item is value attached to that time. For example, <code>0.0 =&gt; 1.0</code> is a time-dependent scalar field having value 1.0 at time 0.0.</p><p>The most simple field is a field that is constant in both time and spatial direction. Discrete, constant, time invariant (DCTI):</p><pre><code class="language-julia">a = DCTI(1.0)</code></pre><pre><code class="language-none">FEMBase.DCTI{Float64}(1.0)</code></pre><p>Then we have discrete, variable, time invariant fields (DVTI). Note the use of <code>NTuple</code> when defining field.</p><pre><code class="language-julia">b = DVTI( (1.0, 2.0) )</code></pre><pre><code class="language-none">FEMBase.DVTI{2,Float64}((1.0, 2.0))</code></pre><p>Discrete, constant, time variant field (DCTV) is constant in spatial direction but can vary in temporal direction. Here, <code>=&gt;</code> syntax is used. New values can be added to field using <code>update!</code>. If there already exists value for that particular time, it will be overridden. It is assumed that content of field in time direction is monotonically increasing, i.e. <span>$t_{i-1} &lt; t_i &lt; t_{i+1}$</span>. For the sake of clarity let&#39;s also mention that <code>update!</code> works for time invariant fields as well if content needs to be updated.</p><pre><code class="language-julia">c = DCTV(0.0 =&gt; 1.0, 1.0 =&gt; 2.0)
update!(c, 2.0 =&gt; 3.0)
c</code></pre><pre><code class="language-none">FEMBase.DCTV{Float64}(Pair{Float64,Float64}[0.0=&gt;1.0, 1.0=&gt;2.0, 2.0=&gt;3.0])</code></pre><p>Discrete, variable, time variant (DVTV) field is the most general one, allowing values of field to vary in both spatial and time direction.</p><pre><code class="language-julia">d = DVTV(0.0 =&gt; (1.0, 2.0), 1.0 =&gt; (2.0, 3.0))
update!(d, 2.0 =&gt; (3.0, 4.0))</code></pre><pre><code class="language-none">3-element Array{Pair{Float64,Tuple{Float64,Float64}},1}:
 0.0=&gt;(1.0, 2.0)
 1.0=&gt;(2.0, 3.0)
 2.0=&gt;(3.0, 4.0)</code></pre><p>In examples above, all fields was scalar fields. Defining vector or tensor fields goes in the same spirit. Only difference is that now we define vectors and tensors, not a single scalar value. They can vary in spatial and time direction in the same way than scalar fields. Here is example of defining the abovementioned vector fields:</p><pre><code class="language-julia">a = DCTI([1.0, 2.0])
b = DVTI(([1.0, 2.0], [2.0, 3.0]))
c = DCTV(0.0 =&gt; [1.0, 2.0], 1.0 =&gt; [2.0, 3.0])
d = DVTV(0.0 =&gt; ([1.0, 2.0], [2.0, 3.0]), 1.0 =&gt; ([2.0, 3.0], [3.0, 4.0]))</code></pre><pre><code class="language-none">FEMBase.DVTV{2,Array{Float64,1}}(Pair{Float64,Tuple{Array{Float64,1},Array{Float64,1}}}[0.0=&gt;([1.0, 2.0], [2.0, 3.0]), 1.0=&gt;([2.0, 3.0], [3.0, 4.0])])</code></pre><h1><a class="nav-anchor" id="Accessing-fields-1" href="#Accessing-fields-1">Accessing fields</a></h1><p>Accessing fields is done using a single command: <code>interpolate</code>. For time varying fields, one can interpolate in time direction. For example, if we have (constant) <span>$[1,2]$</span> at time <span>$t=0.0$</span> and <span>$[3,4]$</span> at time <span>$t=1.0$</span>, linear interpolation yields</p><pre><code class="language-julia">c = DCTV(0.0 =&gt; [1.0,2.0], 1.0 =&gt; [3.0,4.0])
interpolate(c, 0.5)</code></pre><pre><code class="language-none">2-element Array{Float64,1}:
 2.0
 3.0</code></pre><p>If field is spatially varying, a <code>Tuple</code> will be returned, typically having one value for each &quot;node&quot;. This can then be interpolated in spatial direction, typically using basis functions defined on element, e.g. <span>$u = N_i u_i$</span>:</p><pre><code class="language-julia">d = DVTV(0.0 =&gt; (1.0,2.0), 1.0 =&gt; (3.0,4.0))
interpolate(d, 0.5)</code></pre><pre><code class="language-none">(2.0, 3.0)</code></pre><p>Although the two fields above looks quite same, the key difference is that in DCTV field we have a constant vectorial value (defined using square brackets []) and in latter DVTV field we have a scalar value (defined using round brackets) changing in spatial direction from 1.0 to 2.0 at time <span>$t=0.0$</span> and changing from 3.0 to 4.0 at time <span>$t=1.0$</span>.</p><p>One should be always able to interpolate in time direction, even if field is time invariant, to get trivial solution:</p><pre><code class="language-julia">interpolate(a, 0.5), interpolate(b, 0.5),
interpolate(c, 0.5), interpolate(d, 0.5)</code></pre><pre><code class="language-none">([1.0, 2.0], ([1.0, 2.0], [2.0, 3.0]), [2.0, 3.0], (2.0, 3.0))</code></pre><p>For spatially varying fields, one can access to ith element using getindex:</p><pre><code class="language-julia">getindex(a, 1), getindex(b, 1), getindex(b, 2)</code></pre><pre><code class="language-none">([1.0, 2.0], [1.0, 2.0], [2.0, 3.0])</code></pre><p>First time interpolation, then spatial lookup, i.e.</p><pre><code class="language-julia">getindex(interpolate(d, 0.5), 1)</code></pre><pre><code class="language-none">2.0</code></pre><p>By passing already evaluated basis functions to <code>interpolate</code>, field is intepolated in both temporal and spatial direction.</p><pre><code class="language-julia">d = DVTV(0.0 =&gt; (1.0,2.0), 1.0 =&gt; (3.0,4.0))
xi = 0.0
N = [1/2*(1-xi) 1/2*(1+xi)] # evaluated basis functions, linear interpolation
t = 1.0 # time
interpolate(d, t, N)</code></pre><pre><code class="language-none">3.5</code></pre><p>Internally, each field is a subtype of <code>AbstractField</code>. Internally each field has a <code>data</code> which be accessed directly for hacking.</p><pre><code class="language-julia">d.data</code></pre><pre><code class="language-none">2-element Array{Pair{Float64,Tuple{Float64,Float64}},1}:
 0.0=&gt;(1.0, 2.0)
 1.0=&gt;(3.0, 4.0)</code></pre><h1><a class="nav-anchor" id="Continuous-fields-1" href="#Continuous-fields-1">Continuous fields</a></h1><p>Then we have continuous fields which may be useful when defining analytical boundary conditions. For that we have CVTV, where &quot;C&quot; stands for continuous.</p><pre><code class="language-julia">f(xi,t) = xi[1]*xi[2]*t
g = CVTV(f)
g([1.0,2.0],3.0)</code></pre><pre><code class="language-none">6.0</code></pre><h1><a class="nav-anchor" id="Dictionary-fields-1" href="#Dictionary-fields-1">Dictionary fields</a></h1><p>Usually it is assumed that discrete field has values number of nodes or degrees of freedom in element, typically something small like 1-30. There might be cases where it is more practical to define field in a sense that indexing is not continuous or starting from 1. For example, we might want to define field common for a set of elements. In that case it&#39;s natural to think that each index in field corresponds to the certain id-number of node. For example, if we have triangle element connecting nodes 1, 1000 and 100000, we still want to access to that field naturally using <code>getindex</code>, e.g. <code>f[1]</code>, <code>f[1000]</code> and <code>f[100000]</code>. In that case, more appropriate internal structure for field is based on dictionary.</p><p>It only makes sense to define dictionary fields for spatially varying fields. Two new fields are introduced: DVTId and DVTVd, where last &quot;d&quot; stands for &quot;dictionary&quot;.</p><p>Keep on mind, that this type of field has one restriction. If and when this field is typically defined on nodes of several elements, field must be continuous between elements. That is, if field value in node 1000 is for example 1.0, then it&#39;s 1.0 in all elements connecting to that node. To define jumps on field, one must define field element-wise. </p><pre><code class="language-julia"># Define eg. &quot;geometry&quot; for nodes 1,2,3,4.
X = Dict(1=&gt;[0.0,0.0], 1000=&gt;[1.0,0.0], 100000=&gt;[1.0,1.0])
G = DVTId(X)
G[1], G[1000], G[100000]</code></pre><pre><code class="language-none">([0.0, 0.0], [1.0, 0.0], [1.0, 1.0])</code></pre><pre><code class="language-julia">Y = Dict(1=&gt;[1.0,1.0], 1000=&gt;[2.0,1.0], 100000=&gt;[2.0,2.0])
F = DVTVd(0.0 =&gt; X, 1.0 =&gt; Y)
interpolate(F,0.5)[100000]</code></pre><pre><code class="language-none">2-element Array{Float64,1}:
 1.5
 1.5</code></pre><h1><a class="nav-anchor" id="Using-common-constructor-field-1" href="#Using-common-constructor-field-1">Using common constructor <code>field</code></a></h1><p>Now we have introduced total of 7 fields: DCTI, DCTV, DVTI, DVTV, CVTV, DVTId, DVTVd. A good question arises that how to remember all this stuff and is it even necessary? Luckily not, because one can use a single constructor called <code>field</code> to create all kind of fields. Type of field is inspected from data type. You really don&#39;t have to know about this technical stuff, just declare new field using intuition and <code>field</code> command.</p><pre><code class="language-julia">f1 = field(1.0)
typeof(f1)</code></pre><pre><code class="language-none">FEMBase.DCTI{Float64}</code></pre><pre><code class="language-julia">f2 = field((1.0, 2.0))
typeof(f2)</code></pre><pre><code class="language-none">FEMBase.DVTI{2,Float64}</code></pre><pre><code class="language-julia">f3 = field(0.0 =&gt; 1.0)
typeof(f3)</code></pre><pre><code class="language-none">FEMBase.DCTV{Float64}</code></pre><pre><code class="language-julia">f4 = field(0.0 =&gt; (1.0, 2.0), 1.0 =&gt; (2.0, 3.0))
typeof(f4)</code></pre><pre><code class="language-none">FEMBase.DVTV{2,Float64}</code></pre><pre><code class="language-julia">f5 = field((xi,t) -&gt; xi[1]*t)
typeof(f5)</code></pre><pre><code class="language-none">FEMBase.CVTV</code></pre><pre><code class="language-julia">f6 = field(1 =&gt; 1.0, 2 =&gt; 2.0)
typeof(f6)</code></pre><pre><code class="language-none">FEMBase.DVTId{Float64}</code></pre><pre><code class="language-julia">f7 = field(0.0 =&gt; (1=&gt;1.0,10=&gt;2.0), 1.0 =&gt; (1=&gt;2.0,10=&gt;3.0))
typeof(f7)</code></pre><pre><code class="language-none">FEMBase.DVTVd{Float64}</code></pre><h1><a class="nav-anchor" id="Developing-new-fields-1" href="#Developing-new-fields-1">Developing new fields</a></h1><p>If the default ones are not enough, it&#39;s always possible to define new ones. Minimum requirements is that field is a subtype of <code>AbstractField</code> and <code>interpolate</code> has been defined to it.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="basis.html"><span class="direction">Next</span><span class="title">Basis functions</span></a></footer></article></body></html>
