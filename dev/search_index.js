var documenterSearchIndex = {"docs":
[{"location":"materials/#Materials-1","page":"Materials","title":"Materials","text":"","category":"section"},{"location":"results/#Results-1","page":"Results","title":"Results","text":"","category":"section"},{"location":"mesh/#Mesh-1","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"mesh/#","page":"Mesh","title":"Mesh","text":"CurrentModule = FEMBase\nDocTestSetup = quote\n    using FEMBase\nend","category":"page"},{"location":"mesh/#Mesh-structure-1","page":"Mesh","title":"Mesh structure","text":"","category":"section"},{"location":"mesh/#Modifying-mesh-1","page":"Mesh","title":"Modifying mesh","text":"","category":"section"},{"location":"mesh/#Defining-new-mesh-parsers-1","page":"Mesh","title":"Defining new mesh parsers","text":"","category":"section"},{"location":"mesh/#","page":"Mesh","title":"Mesh","text":"Whould work somehow like this:","category":"page"},{"location":"mesh/#","page":"Mesh","title":"Mesh","text":"mutable struct DemoReader <: AbstractMeshReader\n    handle :: String\nend\n\nfunction read_mesh!(m::Mesh, r::DemoReader)\n    # parse file and insert results to `m`.\nend\n\nmesh = Mesh()\nreader = DemoReader(\"file.inp\")\nread_mesh!(mesh, reader)","category":"page"},{"location":"basis/#Basis-functions-1","page":"Basis functions","title":"Basis functions","text":"","category":"section"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"using FEMBase\nusing FEMBase.FEMBasis: eval_dbasis!, jacobian, grad, interpolate,\n                        get_reference_element_coordinates, create_basis\nusing FEMBasis","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Shape functions, also known as basis functions, interpolation polynomials and so on. Typically unknown field variable is interpolated from element nodal values using continuous functions. That is, ","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"u(xit) = sum_i N(xit) u_it","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"math","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Standard Lagrange shape functions are implemented.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Linear shape functions:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Seg2 (2-node segment)\nTri3 (3-node triangle)\nQuad4 (4-node quadrangle)\nTet4 (4-node tetrahedron)\nPyr5 (5-node pyramid)\nWedge6 (6-node wedge)\nHex8 (8-node hexahedra)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Quadratic and biquadratic shape functions:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Seg3\nTri6, Tri7\nQuad8, Quad9\nTet10\nWedge15\nHex20, Hex27","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"NURBS shape functions:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"NSeg\nNSurf\nNSolid","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Creating new basis is done simply by calling that constructor, without any arguments:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Seg2()\nTri3()\nQuad4()","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"The dimensions of basis functions can be determined by size and length. In JuliaFEM, we have a convention that arrays grow on right according to number of nodes and down according to the spatial index. So if we have a row vector boldsymbol N and a column vector boldsymbol u, interpolation goes u = boldsymbol N boldsymbol u:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"N = [1 2 3] # evaluated basis functions\nu = [1, 2, 3] # field value at discrete points\nN*u","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"For example, Quad4 is defined in two dimensions and it has 4 nodes, so","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"B = Quad4()\nsize(B)\nlength(B)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Evaluating basis functions and they partial derivatives with respect to some xi is done efficiently using eval_basis! and eval_dbasis!. For these commands one needs to allocate array outside of the hot loops to get speed.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"N = zeros(1, length(B))\ndN = zeros(size(B)...)\nxi = (0.0, 0.0)\neval_basis!(B, N, xi)\neval_dbasis!(B, dN, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"For Langrange interpolation polynomials, by definition, on each node shape function corresponding to that node gets value of 1 and the rest is zero. Node ordering follows the same defined in e.g. in ABAQUS and in many other FEM softwares. The actual shape of domain can be inspected using command get_reference_element_coordinates:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"get_reference_element_coordinates(Quad4)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"for xi in get_reference_element_coordinates(Quad4)\n    eval_basis!(B, N, xi)\n    println(\"$N at $xi\")\nend","category":"page"},{"location":"basis/#Mathematics-1","page":"Basis functions","title":"Mathematics","text":"","category":"section"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Without knowing anything about the shape of the real domain (after all, basis is usually defined on dimensionless, reference domain), eval_dbasis! is calculating gradient with respect to dimensionless coordinates xi_i, i.e.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"left(fracpartialboldsymbolNpartialboldsymbolxiright)_ij=fracpartial N_jpartialxi_i","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Usually this is not wanted, but instead gradient of basis functions is calculated with respect to natural coordinates X_i,","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"left(fracpartialboldsymbolNpartialboldsymbolXright)_ij=fracpartial N_jpartial X_i","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Without going into the mathematical details, to transform partial derivatives from reference element to natural coordinates, inverse of Jacobian matrix is needed.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"X = ([0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0])\nxi = (0.0, 0.0)\nJ = jacobian(B, X, xi)\ninv(J) * dN","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Or directly, using grad:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"dNdX = grad(B, X, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"If interpolation domain is a manifold, i.e. space having lower dimension than the actual space (read: surface in 3d), Jacobian is not square and inverse cannot be taken.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"X2 = ([0.0,0.0,0.0], [1.0, 0.0,1.0], [1.0,1.0,1.0], [0.0,1.0,0.0])\nxi = (0.0, 0.0)\nJ = jacobian(B, X2, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"One can use Jacobian to calculate surface integral:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"iint_SfmathrmdSigma=iint_Tfleft(boldsymbolxleft(stright)right)leftVert fracpartialboldsymbolxpartial stimesfracpartialboldsymbolxpartial trightVert mathrmdsmathrmdt","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"4*norm(cross(J[1,:], J[2,:])), sqrt(2) # area of manifold","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Gradient of e.g. displacement field or temperature field can be also evaluated, with the same grad function, by adding field u:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"u = ([0.0, 0.0], [1.0, -1.0], [2.0, 3.0], [0.0, 0.0])\nT = (1.0, 2.0, 3.0, 4.0)\ngrad(B, u, X, xi)\ngrad(B, T, X, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"One can interpolate fields using basis, i.e. calculate u = boldsymbolNboldsymbolu as described before:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"interpolate(B, u, xi)\ninterpolate(B, T, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"In \"hot loops\", it's absolutely necessary that no unnecessary memory allcations happen as it is reducing the performance dramatically from C speed. To avoid unnecessary memory allocations, a struct BasisInfo is introduced, containing workspace for calculations.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"bi = BasisInfo(Quad4)\neval_basis!(bi, X, xi)\nbi.J       # Jacobian\nbi.N       # shape functions\nbi.dN      # shape function derivatives, with respect to xi\nbi.detJ    # determinant of Jacobian\nbi.grad    # shape function derivatives, with respect to X\nbi.invJ    # inverse of Jacobian","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Calculating gradient of some field u can be done memory efficiently using this BasisInfo structure:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"gradu = zeros(2, 2)\ngrad!(bi, gradu, u)","category":"page"},{"location":"basis/#Defining-custom-shape-functions-1","page":"Basis functions","title":"Defining custom shape functions","text":"","category":"section"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Depending from the type of shape functions, they can be created more or less automatic way. An ultimate goal is to create all kind of shape functions just by defining the general principles and let computer handle the all boring things and create shape functions automatically using metaprogramming to get efficient code.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"For Lagrange type interpolation, ones needs only to define polynomial and corner points for domain. For example, if domain is 01^2, one can use create_basis, and give polynomial with degree matching to the number of point to interpolate.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"code = create_basis(\n    :MyQuad,\n    \"My special domain\",\n    (\n        (0.0, 0.0),\n        (1.0, 0.0),\n        (1.0, 1.0),\n        (0.0, 1.0),\n    ),\n    \"1 + u + v + u*v\"\n);\n\neval(code)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"What we have defined is a interpolation polynomial and \"corner points\". As a result, we have a new basis MyQuad, working just like expected. All Lagrange polynomials are done like this.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"B = MyQuad()\nxi = (0.5, 0.5)\neval_basis!(B, N, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"In this case, and considering domain, partial derivatives of shape functions are with respect to X, because interpolation polynomials are calculated against real domain and not \"reference domain\". That is, partial derivatives should match to what already calcualated.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"eval_dbasis!(B, dN, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Jacobian should be identity matrix:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"J = jacobian(B, X, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"And taking gradient with respect to X should return also same result than before:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"u = ([0.0, 0.0], [1.0, -1.0], [2.0, 3.0], [0.0, 0.0])\ngrad(B, u, X, xi)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Shape functions can be defined manually and calculate partial derivatives automatically. For example, for pyramid elements typical ansatz approach is not applicable. Some other degenerated elements exists in fracture mechanics.","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"For example, C1-continuous Hermite shape functions ready to approximate Euler-Bernoulli beam equations can be defined as:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"code = create_basis(\n    :C1Hermite,\n    \"C1-continuous Hermite shape functions\",\n    (\n        (0.0,),\n        (0.0,),\n        (1.0,),\n        (1.0,)\n    ),\n    (\n        \"2*u^3 - 3*u^2 + 1\",\n        \"u^3 - 2*u^2 + u\",\n        \"-2*u^3 + 3*u^2\",\n        \"u^3 - u^2\"\n    )\n);\neval(code)","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Again, we should have 1.0 in corresponding nodal point or it's derivative, according to that order we have u(0) u(0) u(1) u(1), so","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"B = C1Hermite()\nN = zeros(1, 4)\ndN = zeros(1, 4)\neval_basis!(B, N, (0.0,))\neval_dbasis!(B, dN, (0.0,))\neval_basis!(B, N, (1.0,))\neval_dbasis!(B, dN, (1.0,))","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"The last option is to build everything from scratch. For that, one must import and define following functions:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Base.size\nBase.length\nFEMBase.getreferenceelement_coordinates\nFEMBase.eval_basis!\nFEMBase.eval_dbasis!","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"As an examples, a simple implementation of P-hierarchical 1d-basis would then be the following:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"import Base: size, length\nimport FEMBase: get_reference_element_coordinates,\n                eval_basis!, eval_dbasis!,\n                AbstractBasis\n\ntype PSeg <: AbstractBasis\n    order :: Int\nend\n\nfunction PSeg()\n    return PSeg(1)\nend\n\nfunction length(basis::PSeg)\n    return basis.order+1\nend\n\nfunction size(basis::PSeg)\n    return (1, basis.order+1)\nend\n\nfunction get_reference_element_coordinates(basis::PSeg)\n    return ((-1.0,), (1.0,))\nend\n\nnothing # hide","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Next, define Legengre polynomials:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"\"\"\"\n    get_legendre_polynomial(n)\n\nReturn Legendgre polynomial of order `n` to inverval ξ ∈ [1, 1].\n\nImplementation uses Bonnet's recursion formula. See\nhttps://en.wikipedia.org/wiki/Legendre_polynomials\n\"\"\"\nfunction get_legendre_polynomial(n)\n    n == 0 && return xi -> 1.0\n    n == 1 && return xi -> xi\n    Pm1 = get_legendre_polynomial(n-1)\n    Pm2 = get_legendre_polynomial(n-2)\n    A(xi) = (2.0*n-1.0)*xi*Pm1(xi)\n    B(xi) = (n-1.0)*Pm2(xi)\n    return xi -> (A(xi)-B(xi))/n\nend\n\n\"\"\"\n    get_legendre_polynomial_derivative(n)\n\nReturn derivative of Legendgre polynomial of order `n` to\ninverval ξ ∈  [-1, 1]\n\"\"\"\nfunction get_legendre_polynomial_derivative(n)\n    n == 0 && return xi -> 0.0\n    n == 1 && return xi -> 1.0\n    Pm1 = get_legendre_polynomial_derivative(n-1)\n    Pm2 = get_legendre_polynomial_derivative(n-2)\n    A(xi) = (2.0*(n-1.0)+1.0)*xi*Pm1(xi)\n    B(xi) = (n+1.0-1.0)*Pm2(xi)\n    return xi -> (A(xi)-B(xi))/(n-1.0)\nend\n\nnothing # hide","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"And finally implement eval_basis! and eval_dbasis! functions:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"function eval_basis!{T}(basis::PSeg, N::Matrix{T}, xi::Tuple{T})\n    n = length(basis)\n    t = xi[1]\n    N[1] = 0.5*(1-t)\n    N[2] = 0.5*(1+t)\n    n < 3 && return N\n    for i=3:n\n        j = i-1\n        P1 = get_legendre_polynomial(j)\n        P2 = get_legendre_polynomial(j-2)\n        N[i] = 1.0/sqrt(2.0*(2.0*j-1.0))*(P1(t)-P2(t))\n    end\n    return N\nend\n\nfunction eval_dbasis!{T}(basis::PSeg, dN::Matrix{T}, xi::Tuple{T})\n    n = length(basis)\n    t = xi[1]\n    dN[1] = -0.5\n    dN[2] = 0.5\n    n < 3 && return N\n    for i=3:n\n        j = i-1\n        P1 = get_legendre_polynomial_derivative(j)\n        P2 = get_legendre_polynomial_derivative(j-2)\n        dN[i] = 1.0/sqrt(2.0*(2.0*j-1.0))*(P1(t)-P2(t))\n    end\n    return dN\nend\n\nnothing # hide","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"Let's try it:","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"B = PSeg()\nN = zeros(1, length(B))\neval_basis!(B, N, (0.0,))\nB.order = 2\nN = zeros(1, length(B))\neval_basis!(B, N, (0.0,))","category":"page"},{"location":"basis/#","page":"Basis functions","title":"Basis functions","text":"(Image: Hierarchical shape functions up to order 6)","category":"page"},{"location":"solvers/#Analyses-and-solvers-1","page":"Analyses and solvers","title":"Analyses and solvers","text":"","category":"section"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"After a global assembly for each problem is ready, they must somehow put together, usually construct a linear system boldsymbolAboldsymbolx = boldsymbolb , solve system of equations and potentially update solution back to problems / elements.","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"For this task we have Analysis. Just like problems are \"containers\" for a set of some elements, analyses are containers for a set of problems, performing some spesific task. This task usually (but not always) involves solving big systems of equations.","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"For example, typical nonlinear quasistatic analysis is","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"initialize problems (if needed)\nassemble problems\ncombine assemblies to construct a linear system boldsymbolAboldsymbolx = boldsymbolb\nsolve linear system, as effectively as possible\nupdate solution back to problems or elements\npostprocess fields\nwrite requested results to file\ncheck convergence, if not converged, go back to 2.","category":"page"},{"location":"solvers/#Implementing-solver-for-LinearSystem-1","page":"Analyses and solvers","title":"Implementing solver for LinearSystem","text":"","category":"section"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"When models gets big enough, step 4 is dominating in a solution process. For that reason we have abstract type AbstractLinearSystemSolver which can be subclassed to construct own solution strategy. This strategy can be, for example to use Julia's build-in solvers, MUMPS, iterative solvers and so on. And to make this as standard as possible, we have LinearSystem containing all the relevant matrices, i.e.","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"beginbmatrix\nboldsymbolK  boldsymbolC_1\nboldsymbolC_2  boldsymbolD\nendbmatrix\nbeginbmatrix\nboldsymbolu\nboldsymbollambda\nendbmatrix =\nbeginbmatrix\nboldsymbolf\nboldsymbolg\nendbmatrix","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"using FEMBase\nusing FEMBase: LinearSystem, AbstractLinearSystemSolver,\n               AbstractAnalysis, Analysis, Element, Problem,\n               Quad4, get_problems\nimport FEMBase: assemble_elements!, run!, can_solve, solve!\n\ntype Heat <: FieldProblem\nend\n\nfunction get_unknown_field_name(::Problem{Heat})\n    return \"temperature\"\nend\n\nfunction assemble_elements!{B}(problem::Problem{Heat}, assembly::Assembly,\n                               elements::Vector{Element{B}}, time::Float64)\n\n    println(\"Assembling volume elements of kind $B\")\n    bi = BasisInfo(B)\n    ndofs = length(B)\n    Ke = zeros(ndofs, ndofs)\n    fe = zeros(ndofs)\n\n    for element in elements\n        fill!(Ke, 0.0)\n        fill!(fe, 0.0)\n        for ip in get_integration_points(element)\n            J, detJ, N, dN = element_info!(bi, element, ip, time)\n            k = element(\"thermal conductivity\", ip, time)\n            Ke += ip.weight * k*dN'*dN * detJ\n            if haskey(element, \"heat source\")\n                f = element(\"heat source\", ip, time)\n                fe += ip.weight * N'*f * detJ\n            end\n        end\n        gdofs = get_gdofs(problem, element)\n        add!(assembly.K, gdofs, gdofs, Ke)\n        add!(assembly.f, gdofs, fe)\n    end\n\nend\n\nfunction assemble_elements!{B<:Union{Seg2,Seg3}}(problem::Problem{Heat},\n                                                 assembly::Assembly,\n                                                 elements::Vector{Element{B}},\n                                                 time::Float64)\n\n    println(\"Assembling boundary elements of kind $B\")\n    bi = BasisInfo(B)\n    ndofs = length(B)\n    fe = zeros(ndofs)\n\n    for element in elements\n        haskey(element, \"heat flux\") || continue\n        fill!(fe, 0.0)\n        for ip in get_integration_points(element)\n            J, detJ, N, dN = element_info!(bi, element, ip, time)\n            g = element(\"heat flux\", ip, time)\n            fe += ip.weight * N'*g * detJ\n        end\n        gdofs = get_gdofs(problem, element)\n        add!(assembly.f, gdofs, fe)\n    end\n\nend\n\ntype DirichletBC <: BoundaryProblem\nend\n\nfunction assemble_elements!{E}(problem::Problem{DirichletBC},\n                               assembly::Assembly,\n                               elements::Vector{Element{E}},\n                               time::Float64)\n\n    name = get_parent_field_name(problem)\n    dim = get_unknown_field_dimension(problem)\n\n    println(\"Assembling Dirichlet boundary condition\")\n    println(\"Field name = $name, dofs/node = $dim\")\n\n    data = Dict{Int64,Float64}()\n    for element in elements\n        for i=1:dim\n            haskey(element, \"$name $dim\") || continue\n            gdofs = get_gdofs(problem, element)\n            ldofs = gdofs[i:dim:end]\n            xis = get_reference_element_coordinates(E)\n            for (ldof, xi) in zip(ldofs, xis)\n                data[ldof] = interpolate(element, \"$name $dim\", xi, time)\n            end\n        end\n    end\n\n    for (dof, val) in data\n        add!(assembly.C1, dof, dof, 1.0)\n        add!(assembly.C2, dof, dof, 1.0)\n        add!(assembly.g, dof, val)\n    end\n\nend\n","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"First setup linear system, we take matrices introduced in the context of [Problems]:","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"ls = LinearSystem(5)\nls.K = sparse([  4.0  -1.0  -2.0  -1.0   0.0\n                -1.0   7.0  -4.0  -2.0   0.0\n                -2.0  -4.0  10.0  -1.0  -3.0\n                -1.0  -2.0  -1.0   4.0   0.0\n                 0.0   0.0  -3.0   0.0   3.0])\nls.C1 = sparse([ 1.0  0.0  0.0  0.0  0.0\n\t         0.0  0.0  0.0  0.0  0.0\n\t         0.0  0.0  0.0  0.0  0.0\n\t         0.0  0.0  0.0  1.0  0.0\n\t         0.0  0.0  0.0  0.0  0.0])\nls.C2 = ls.C1\nls.f = sparsevec([33.0, 33.0, 165.0, 33.0, 132.0])\nnothing # hide","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"For example, a simple solver for small problems would be to use lufact from UMFPACK:","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"\ntype LUSolver <: AbstractLinearSystemSolver\n    # may contain some solver-spesific settings\nend\n\n\"\"\"\n    solve!(ls::LinearSystem, solver::LUSolver)\n\nSolve linear system using LU factorization. If final system has zero rows,\nadd 1 to diagonal to make matrix non-singular.\n\"\"\"\nfunction solve!(ls::LinearSystem, solver::LUSolver)\n\n    println(\"Solving system using LUSolver\")\n\n    A = [ls.K ls.C1; ls.C2 ls.D]\n    b = [ls.f; ls.g]\n\n    # add 1.0 to diagonal for any zero rows in system\n    p = ones(2*ls.dim)\n    p[unique(rowvals(A))] = 0.0\n    A += spdiagm(p)\n\n    # solve A*x = b using LU factorization and update solution vectors\n    x = lufact(A) \\ full(b)\n    ls.u = x[1:ls.dim]\n    ls.la = x[ls.dim+1:end]\n\n    return nothing\nend\n\nnothing # hide","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"To test it:","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"solver = LUSolver()\nsolve!(ls, solver)\nfull(ls.u)\nfull(ls.la)","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"We try to be clever with solvers, because solution of linear system is taking the most of the time in analysis for big models. It's possible to build a list of solvers which are then run in order, so if first one cannot solve the system, then we can try the next one and so on. For example, direct solvers are very robust but they need quite lot of memory for factorization. If computer / cluster has enough of memory, we can prefer direct solver over iterative ones. If stiffness matrix is symmetric, and problem is positive definite, Cholesky decomposition is preferred over LU decomposition and so on. Before starting the actual solution, one can study matrix structure using can_solve:","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"type FakeSolver <: AbstractLinearSystemSolver\nend\n\nfunction can_solve(ls::LinearSystem, solver::FakeSolver)\n    if issymmetric(ls.K)\n        return (true, \"OK\")\n    else\n        return (false, \"stiffness matrix not symmetric\")\n    end\nend\n\nnothing # hide","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"solvers = [FakeSolver(), LUSolver()]\nls.K[1,2] += 1\nsolve!(ls, solvers)","category":"page"},{"location":"solvers/#Implementing-new-analyses-1","page":"Analyses and solvers","title":"Implementing new analyses","text":"","category":"section"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"Like said, Analysis is a type containing all problems and is performing some sort of operation with them. Typically this can be a solution of static or dynamic equilibrium, eigenvalue analysis, linear perturbation analysis or doing some postprocessing for already done analysis, like fatigue analysis, calculating critical stresses and so on.","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"In industrial computing, a bigger workflow typically contains several different analyses. Compared to some commerfial FEM softwares, e.g. ABAQUS, Analysis can be consided as STEP, but in a more general sense. Because Julia is a real programming language, one can then create, for example, an optimization loop, combining several different analyses to optimize model against some design goal.","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"There's not so much rules about how to define new analysis. It must be a subtype of AbstractAnalysis and implement run!-function. As a minimal working example, implementation for static analysis would then be:","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"type Static <: AbstractAnalysis\n    time :: Float64\nend\n\nfunction Static()\n    return Static(0.0)\nend\n\nfunction run!(analysis::Analysis{Static})\n\n    time = analysis.properties.time\n    problems = get_problems(analysis)\n\n    # assemble matrices for all problems\n    N = 0 # size of resulting matrix\n    for problem in problems\n        assemble!(problem, time)\n        N = max(N, size(problem.assembly.K, 2))\n    end\n\n    # create new LinearSystem and add assemblies to that\n    ls = LinearSystem(N)\n\n    for problem in problems\n        ls.K += sparse(problem.assembly.K, N, N)\n        ls.f += sparse(problem.assembly.f, N, 1)\n        ls.C1 += sparse(problem.assembly.C1, N, N)\n        ls.C2 += sparse(problem.assembly.C2, N, N)\n        ls.D += sparse(problem.assembly.D, N, N)\n        ls.g += sparse(problem.assembly.g, N, 1)\n    end\n\n    # solve linear system using e.g. LUSolver\n    solve!(ls, LUSolver())\n\n    # update solution back to problems\n    u = Dict(i=>j for (i,j) in enumerate(ls.u))\n    for problem in problems\n        is_field_problem(problem) || continue\n        field_name = get_unknown_field_name(problem)\n        elements = get_elements(problem)\n        update!(elements, field_name, time => u)\n    end\nend\n\nnothing # hide","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"To put everything together, typical solution process of time-intependent variational problem looks the following:","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"X = Dict(1 => [0.0, 0.0],\n         2 => [1.0, 0.0],\n         3 => [1.0, 1.0],\n         4 => [0.0, 1.0],\n         5 => [2.0, 1.0])\n\nel1 = Element(Quad4, [1, 2, 3, 4])\nel2 = Element(Tri3, [3, 2, 5])\nel3 = Element(Seg2, [3, 5])\nelements = [el1, el2, el3]\nupdate!(elements, \"geometry\", X)\nupdate!(elements, \"thermal conductivity\", 6.0)\nupdate!(el3, \"heat flux\", 264.0)\nupdate!(el1, \"heat source\", 132.0)\nproblem = Problem(Heat, \"test problem\", 1)\nadd_elements!(problem, elements)\n\nbel1 = Element(Seg2, [1, 4])\nupdate!(bel1, \"geometry\", X)\nupdate!(bel1, \"temperature 1\", 0.0)\nbc = Problem(DirichletBC, \"fixed\", 1, \"temperature\")\nadd_elements!(bc, [bel1])\n\nanalysis = Analysis(Static, \"static analysis of test problem\")\nadd_problems!(analysis, [problem, bc])\nrun!(analysis)","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"After analysis is ready, temperature is updated to elements:","category":"page"},{"location":"solvers/#","page":"Analyses and solvers","title":"Analyses and solvers","text":"el1(\"temperature\", 0.0)\nel2(\"temperature\", 0.0)\nel3(\"temperature\", 0.0)","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"EditURL = \"https://github.com/JuliaFEM/FEMBase.jl/blob/master/test/test_fields.jl\"","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"using FEMBase, Test","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"From the beginning of a project we had a clear concept in our mind: \"everything is a field\". That is, everything can vary temporally and spatially. We think that constant is just a special case of field which does not vary in temporal nor spatial direction. Fields can vary in spatial direction, i.e. can be either constant or variable, and in temporal direction, i.e. can be time variant or time invariant. From this pondering we can think that there exists four kind of (discrete) fields:","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"discrete, constant, time invariant (DCTI)\ndiscrete, variable, time invariant (DVTI)\ndiscrete, constant, time variant (DCTV)\ndiscrete, variable, time variant (DVTV)","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Discrete, in this context, means that field is defined in point-wise in 1 ldots n locations, from where it is then interpolated to whole domain using some interpolation polynomials, i.e.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"u(xi t) = sum_i u_it N_i(xit)","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"math where     N_i(xi t) is the basis function or interpolation polymial corresponding to i^{th} discrete value and     u_i is the discrete value.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Then we have continuous fields, which are defined in whole domain, or at least not point-wise. By following the already used abbreviations, we have four more fields:","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"continuous, constant, time invariant (CCTI)\ncontinuous, variable, time invariant (CVTI)\ncontinuous, constant, time variant (DCTV)\ncontinuous, variable, time variant (CVTV)","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Continuous, again in this context, does not mean that field has to be defined everywhere. It's enough that it's defined in function of spatial and/or temporal coordinates, i.e. we have u equiv u(xi t), without a some spesific basis needed to interpolate from discrete values.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Field itself can be in principle anything. However, usually either scalar, vector or tensor (matrix). Time does not to have be real, it can be for example angle of some rotating machine or even complex value.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"From these starting points, we assume that the mentioned field system can describe all imaginable situations.","category":"page"},{"location":"fields/#Creating-new-fields-1","page":"Fields","title":"Creating new fields","text":"","category":"section"},{"location":"fields/#","page":"Fields","title":"Fields","text":"For discrete fields that are varying in spatial direction, value for each discrete point is defined using NTuple. The order of points is implicitly assumed to be same than node ordering in ABAQUS. That is, first corner nodes in anti-clockwise direction and after that middle nodes.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"For example, (1, 2, 3, 4) is a scalar field having length of 4 and ([1,2],[2,3],[3,4],[4,5]) is a vector field having length of 4.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"For fields that are varying in temporal direction, time => value syntax is used. The first item in pair is time (or similar) and second item is value assigned to that time. For example, 0.0 => 1.0 is a time-dependent scalar field having value 1.0 at time 0.0.","category":"page"},{"location":"fields/#Dicrete,-constant,-time-invariant-field-(DCTI)-1","page":"Fields","title":"Dicrete, constant, time invariant field (DCTI)","text":"","category":"section"},{"location":"fields/#","page":"Fields","title":"Fields","text":"The most simple field is a field that is constant in both time and spatial direction. Discrete, constant, time invariant field. For example, youngs modulus could be this kind of field.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"a = DCTI(1)","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Accessing data is done using interpolate. In FEM codes, we try to hide the actual type of the field, so for example interpolating constant field works, but the result is quite unsuprising.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"@test interpolate(a, 0.0) == 1","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Field value value can be updated with update! function:","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"update!(a, 2)\n@test a == 2","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Constant field of course doesn't have to be scalar field. It can be e.g. vector field. I use here packate Tensors.jl because of its excellent performance and other features, but normal Vector would work just fine also:","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"using Tensors\n\nb = DCTI(Vec(1, 2))","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Interpolation, again, returns just the original data:","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"@test interpolate(b, 0.0) == [1, 2]","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Updating field is done using update!-function:","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"update!(b, Vec(2, 3))\n@test interpolate(b, 0.0) == [2, 3]","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Constant tensor field:","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"c = DCTI(Tensor{2,2}((1.0, 2.0, 3.0, 4.0)))","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"Data can be accessed also using getindex. Also things like length and size are defined.","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"@test interpolate(c, 0.0) == [1 3; 2 4]\n@test c[1] == [1 3; 2 4]\n@test length(c) == 4\n@test size(c) == (2, 2)","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"For now everything might look like extra complexity, but later on we see how to combine field with some basis functions in order to interpolate in element domain. Another nice feature is that we can interpolate fields in time. In this particular case of time invariant fields it of course doesn't give anything extra.","category":"page"},{"location":"fields/#Dicrete,-variable,-time-invariant-fields-(DVTI)-1","page":"Fields","title":"Dicrete, variable, time invariant fields (DVTI)","text":"","category":"section"},{"location":"fields/#","page":"Fields","title":"Fields","text":"@testset \"DVTI field\" begin","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"scalar field","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"    a = DVTI((1, 2))\n    @test a[1] == 1\n    @test a[2] == 2\n    @test interpolate(a, 0.0) == (1, 2)\n    update!(a, (2, 3))\n    @test a == (2, 3)\n    @test (2, 3) == a","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"vector field","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"    b = DVTI(([1, 2], [2, 3]))\n    @test b[1] == [1, 2]\n    @test b[2] == [2, 3]\n    @test interpolate(b, 0.0) == ([1, 2], [2, 3])\n    update!(b, ([2, 3], [4, 5]))\n    @test b == ([2, 3], [4, 5])","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"tensor field","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"    c = DVTI(([1 2; 3 4], [2 3; 4 5]))\n    @test c[1] == [1 2; 3 4]\n    @test c[2] == [2 3; 4 5]\n    @test interpolate(c, 0.0) == ([1 2; 3 4], [2 3; 4 5])\n    update!(c, ([2 3; 4 5], [5 6; 7 8]))\n    @test c == ([2 3; 4 5], [5 6; 7 8])\n\n    d = DVTI(2, 3)\n    @test a == d\nend\n\n@testset \"DCTV field\" begin","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"scalar field","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"    a = DCTV(0.0 => 0.0, 1.0 => 1.0)\n    @test isapprox(interpolate(a, -1.0), 0.0)\n    @test isapprox(interpolate(a, 0.0), 0.0)\n    @test isapprox(interpolate(a, 0.5), 0.5)\n    @test isapprox(interpolate(a, 1.0), 1.0)\n    update!(a, 1.0 => 2.0)\n    @test isapprox(interpolate(a, 0.5), 1.0)\n    update!(a, 2.0 => 1.0)\n    @test isapprox(interpolate(a, 1.5), 1.5)","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"vector field","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"    b = DCTV(0.0 => [1.0, 2.0], 1.0 => [2.0, 3.0])\n    @test isapprox(interpolate(b, 0.5), [1.5, 2.5])","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"tensor field","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"    c = DCTV(0.0 => [1.0 2.0; 3.0 4.0], 1.0 => [2.0 3.0; 4.0 5.0])\n    @test isapprox(interpolate(c, 0.5), [1.5 2.5; 3.5 4.5])\nend\n\n@testset \"DVTV field\" begin","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"scalar field","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"    a = DVTV(0.0 => (0.0, 1.0), 1.0 => (1.0, 0.0))\n    update!(a, 2.0 => (2.0, 0.0))\n    r = interpolate(a, 0.5)\n    @test isapprox(r[1], 0.5)\n    @test isapprox(r[2], 0.5)\n    update!(a, 2.0 => (4.0, 0.0))\nend\n\n@testset \"CVTV field\" begin\n    f = CVTV((xi, t) -> xi[1] * xi[2] * t)\n    @test isapprox(f([1.0, 2.0], 3.0), 6.0)\nend\n\n@testset \"Dictionary fields\" begin\n    X = Dict(1 => [0.0, 0.0], 1000 => [1.0, 0.0], 100000 => [1.0, 1.0])\n    G = DVTId(X)\n    @test isapprox(G[1], X[1])\n    @test isapprox(G[1000], X[1000])\n    @test isapprox(G[100000], X[100000])\n    Y = Dict(1 => [2.0, 2.0], 1000 => [3.0, 2.0], 100000 => [3.0, 3.0])\n    F = DVTVd(0.0 => X, 1.0 => Y)\n    @test isapprox(interpolate(F, 0.5)[100000], [2.0, 2.0])\nend\n\n@testset \"update dictionary field\" begin\n    f1 = Dict(1 => 1.0, 2 => 2.0, 3 => 3.0)\n    f2 = Dict(1 => 2.0, 2 => 3.0, 3 => 4.0)\n    fld = DVTVd(0.0 => f1)\n    update!(fld, 1.0 => f2)\n    @test isapprox(interpolate(fld, 0.5)[1], 1.5)\n    update!(fld, 1.0 => f1)\n    @test isapprox(interpolate(fld, 0.5)[1], 1.0)\nend\n\n@testset \"use of common constructor field\" begin\n    @test isa(field(1.0), DCTI)\n    @test isa(field(1.0 => 1.0), DCTV)\n    @test isa(field((1.0, 2.0)), DVTI)\n    @test isa(field(1, 2), DVTI)\n    @test isa(field(1.0 => (1.0, 2.0)), DVTV)\n    @test isa(field((xi, t) -> xi[1] * t), CVTV)\n    @test isa(field(1 => [1.0, 2.0], 10 => [2.0, 3.0]), DVTId)\n    @test isa(field(0.0 => (1 => 1.0, 10 => 2.0), 1.0 => (1 => 2.0, 10 => 3.0)), DVTVd)\n    X = Dict(1 => [0.0, 0.0], 2 => [1.0, 0.0])\n    X1 = field(X)\n    X2 = field(0.0 => X)\n    @test isa(X1, DVTId)\n    @test isa(X2, DVTVd)\nend\n\n@testset \"general interpolation\" begin\n    a = [1, 2, 3]\n    b = (2, 3, 4)\n    @test interpolate(a, b) == 2 + 6 + 12\n    a = (1, 2)\n    b = (2, 3, 4)\n    @test interpolate(a, b) == 2 + 6\n    @test_throws AssertionError interpolate(b, a)\nend","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"","category":"page"},{"location":"fields/#","page":"Fields","title":"Fields","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-Documentation-1","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/#","page":"API Documentation","title":"API Documentation","text":"CurrentModule = FEMBase\nDocTestSetup = quote\n    using FEMBase\nend","category":"page"},{"location":"api/#Fields-1","page":"API Documentation","title":"Fields","text":"","category":"section"},{"location":"api/#Elements-1","page":"API Documentation","title":"Elements","text":"","category":"section"},{"location":"api/#","page":"API Documentation","title":"API Documentation","text":"interpolate(element::Element, field_name::String, time::Float64)","category":"page"},{"location":"api/#Problems-1","page":"API Documentation","title":"Problems","text":"","category":"section"},{"location":"api/#","page":"API Documentation","title":"API Documentation","text":"assemble_elements!","category":"page"},{"location":"api/#FEMBase.assemble_elements!","page":"API Documentation","title":"FEMBase.assemble_elements!","text":"assemble_elements!(problem, assembly, elements, time)\n\nAssemble elements for problem.\n\nThis should be overridden with own assemble_elements!-implementation.\n\n\n\n\n\n","category":"function"},{"location":"developing/#Developing-new-input/output-interfaces-1","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"","category":"section"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"E.g. mesh reader or results writer.","category":"page"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"mutable struct MeshReader <: AbstractMeshReader\nend\n\n\"\"\"\n    read_mesh(mesh::MeshReader, data)\n\nReads mesh from disk/memory/cloud/sql/etc. and returns Mesh object\n\"\"\"\nfunction read_mesh(mesh::MeshReader, filename::String)\n    # do something ...\nend","category":"page"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"mutable struct ResultsWriter <: AbstractResultsWriter\nend\n\n\"\"\"\n    write_results!(results::ResultsWriter, data)\n\nGiven data, write calculation results back to disk/memory/cloud/sql/etc.\n\"\"\"\nfunction write_results!(results::ResultsWriter, data)\n    # write results ...\nend","category":"page"},{"location":"developing/#Developing-new-physical-models-1","page":"Developing new input/output interfaces","title":"Developing new physical models","text":"","category":"section"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"Starting point is a weak formulation, which is then discretized to elements.","category":"page"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"mutable struct Heat <: AbstractProblem\nend\n\n\"\"\"\n    assemble!(settings::Heat, problem::Problem, assembly::Assembly, elements::Vector{Element}, time::Float64)\n\nGiven `problem` spesification, assemble `elements` to global stiffness matrix and force\nvector defined in `assembly` for some given `time`.\n\"\"\"\nfunction assemble!(settings::Heat, problem::Problem, assembly::Assembly,\n                   elements::Vector{Element}, time::Float64)\n    # integrate local matrices and add them to assembly\nend","category":"page"},{"location":"developing/#Developing-new-material-model-1","page":"Developing new input/output interfaces","title":"Developing new material model","text":"","category":"section"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"Aim is to define material response given data.","category":"page"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"mutable struct LinearIsotropic <: AbstractMaterial\nend\n\n\"\"\"\n    calculate_material_response!(material::LinearIsotropic, data)\n\nGiven strain tensor and some other quantities, calculate material response\n\"\"\"\nfunction calculate_response!(material::LinearIsotropic, data)\n    # given strain tensor and some other quantities, calculate stress\nend","category":"page"},{"location":"developing/#Developing-new-interpolation-functions-1","page":"Developing new input/output interfaces","title":"Developing new interpolation functions","text":"","category":"section"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"E.g. basis functions","category":"page"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"type LinQuad4Basis <: AbstractBasis\nend\n\n\"\"\"\n    evaluate_basis!(basis::LinQuad4Basis, element::Element, xi, time, N::Matrix{Float64})\n\nEvaluate basis functions at some point $\\xi$ and store results to `N`.\n\"\"\"\nfunction evaluate_basis!(basis::LinQuad4Basis, element::Element, xi, time, N::Matrix{Float64})\n    # populate N with new basis\nend","category":"page"},{"location":"developing/#Developing-new-integration-rules-1","page":"Developing new input/output interfaces","title":"Developing new integration rules","text":"","category":"section"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"mutable struct Quad4PointGaussLegendre <: AbstractIntegrationRule\nend\n\n\"\"\"\n    get_integration_points(q::Quad4PointQaussLegendre)\n\nReturn integration point locations and weights.\n\"\"\"\nfunction get_integration_points(q::Quad4PointGaussLegendre)\n    # return integration points\nend","category":"page"},{"location":"developing/#Developing-new-solver-1","page":"Developing new input/output interfaces","title":"Developing new solver","text":"","category":"section"},{"location":"developing/#","page":"Developing new input/output interfaces","title":"Developing new input/output interfaces","text":"mutable struct ImplicitTimeSolver <: AbstractSolver\nend\n\n\"\"\"\n    solve!(settings::ImplicitTimeSolver, solver::Solver, time)\n\nAssemble problems, solve problem, update problems, write results and so on.\n\"\"\"\nfunction solve!(settings::ImplicitTimeSolver, solver::Solver, time)\n    # do solution\nend","category":"page"},{"location":"elements/#Elements-1","page":"Elements","title":"Elements","text":"","category":"section"},{"location":"elements/#","page":"Elements","title":"Elements","text":"In JuliaFEM, elements can be considered as \"containers\", combining fields and basis functions described above. Among that, element has information about topology (connectivity) and numerical integration rule. These fundamentals forms a finite element, the backbone of finite element method.","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"using FEMBase","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"New elements are constructed by passing basis type (e.g. Seg2, Quad4, Tet10, ...) to Element and list of id numbers to where element is topologically connected.","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"el = Element(Quad4, [1, 2, 3, 4])","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"Setting fields to element is done using a command update!, which either creates a new field if field with that name does not already exist, or updates the old one. Typically, at least field called geometry needs to be defined to element as it's used to calculate Jacobian of element. Fields can be discrete, continuous, time invariant or variant, variable or constant, or anything else that is subclassed from AbstractField.","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"X = Dict(1 => [0.0,0.0], 2=>[1.0,0.0], 3=>[1.0,1.0], 4=>[0.0,1.0])\nupdate!(el, \"geometry\", X)","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"Internally, fields are stored in a Dict:","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"el.fields","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"The command update! is automatically inspecting field type based in input. For example, to define temporal field varying spatially:","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"u0 = ([0.0,0.0], [0.0,0.0], [0.0,0.0], [0.0,0.0])\nu1 = ([0.0,0.0], [0.0,0.0], [0.5,0.0], [0.0,0.0])\nupdate!(el, \"displacement\", 0.0 => u0)\nupdate!(el, \"displacement\", 1.0 => u1)\nel.fields","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"Interpolating of fields can be done using syntax Element(field_name, xi, time). For example, position of material particle X in initial configuration and deformed configuration in the middle of the element at time t=1 can be found as","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"xi = (0.0, 0.0)\ntime = 1.0\nX = el(\"geometry\", xi, time)\nu = el(\"displacement\", xi, time)\nx = X+u","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"Jacobian, determinant of Jacobian and gradient of field can be calculated adding extra argument Val{:Jacobian}, Val{:detJ}, Val{:Grad} to the above command and not passing field name, i.e.","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"el(xi, time, Val{:Jacobian})\nel(xi, time, Val{:detJ})\nel(xi, time, Val{:Grad})","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"Usually what is needed when calculating local stiffness matrices is a gradient of some field. For example, displacement gradient and temperature gradient can be obtained following way:","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"gradu = el(\"displacement\", xi, time, Val{:Grad})\nupdate!(el, \"temperature\", (1.0, 2.0, 3.0, 4.0))\ngradT = el(\"temperature\", xi, time, Val{:Grad})","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"Accessing integration points of element is done using function get_integration_points. Combining interpolation and integration one can already calculate local matrices of a single element or, for example area and strain energy:","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"update!(el, \"lambda\", 96.0)\nupdate!(el, \"mu\", 48.0)\n\nA = 0.0\nW = 0.0\nfor ip in get_integration_points(el)\n    detJ = el(ip, time, Val{:detJ})\n    A += ip.weight * detJ\n    ∇u = el(\"displacement\", ip, time, Val{:Grad})\n    E = 1/2*(∇u + ∇u')\n    λ = el(\"lambda\", ip, time)\n    μ = el(\"mu\", ip, time)\n    W += ip.weight * ( λ/2*trace(E*E') + μ*trace(E)^2) * detJ\nend\n\nprintln(\"Area: $A\")\nprintln(\"Strain energy: $W\")","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"To calculate local stiffness matrix for Poisson problem:","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"K = zeros(4,4)\nupdate!(el, \"coefficient\", 36.0)\nfor ip in get_integration_points(el)\n    dN = el(ip, time, Val{:Grad})\n    detJ = el(ip, time, Val{:detJ})\n    c = el(\"coefficient\", ip, time)\n    K += ip.weight * c*dN'*dN * detJ\nend\nK","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"For more memory efficient code it's a good idea to use BasisInfo and element_info! which allocates working memory to calculate all \"basic stuff\" for a single integration point, like Jacobian, determinant of Jacobian, basis and it's partial derivatives with respect to reference configuration X.","category":"page"},{"location":"elements/#","page":"Elements","title":"Elements","text":"bi = BasisInfo(Quad4)\nfill!(K, 0.0)\nfor ip in get_integration_points(el)\n    J, detJ, N, dN = element_info!(bi, el, ip, time)\n    c = el(\"coefficient\", ip, time)\n    K += ip.weight * c*dN'*dN * detJ\nend\nK","category":"page"},{"location":"elements/#Using-analytical-fields-1","page":"Elements","title":"Using analytical fields","text":"","category":"section"},{"location":"elements/#Creating-fields-depending-from-other-fields-1","page":"Elements","title":"Creating fields depending from other fields","text":"","category":"section"},{"location":"theory/#Theory-1","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"testing/#Testing-extensions-1","page":"Testing extensions","title":"Testing extensions","text":"","category":"section"},{"location":"testing/#","page":"Testing extensions","title":"Testing extensions","text":"Own extensions to JuliaFEM can be done to own separate packages which are then used in JuliaFEM. The main idea is that FEMBase.jl is giving all supporting functions and types for all kind of extensions. Extensions lives in their own modules. Extensions can be tested using FEMBase.Test, which itself is a extension to FEMBase, containing types introduced in this manual.","category":"page"},{"location":"testing/#","page":"Testing extensions","title":"Testing extensions","text":"Some guidelines:","category":"page"},{"location":"testing/#","page":"Testing extensions","title":"Testing extensions","text":"use Coverage.jl to check coverage, should be 100 %\nuse Lint.jl to check syntax\nno use of tabulators in files allowed\nno use of fancy utf-8 in code\nlicence header should match in every source file to one defined in main file\nkeep version history clean and understandable\nunit tests should test only implemented functions, nothing else","category":"page"},{"location":"integration/#Integration-1","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"postprocessing/#Postprocessing-1","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"problems/#Problems-1","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"The role of problems in JuliaFEM is to work as a container for a set of elements. They contain elements and an information how the elements are assembled to the global assembly. The key point is that thanks to multiple dispatch, each problem defines also the physics behind discretization and all problems are assembled using a command assemble_elements!. ","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"As an example, a heat equation in two dimensions is discretized. Mathematically known also as Poisson problem. Strong form of the problem is","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":" nabla cdot (-nabla u ) = f    text in  Omega \n                         u = u_0  text on  Gamma_mathrmD \n      fracupartial n = g    text on  Gamma_mathrmN","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"and corresponding variational problem is to find uinmathcalU such that for all vinmathcalV","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"int_Omegaknabla ucdotnabla vmathrmdx=int_Omegafvmathrmdx+int_Gamma_mathrmNgvmathrmds","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Let's call k thermal conductivity, f heat source and g heat flux.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"using FEMBase\nimport FEMBase: assemble_elements!, get_unknown_field_name","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Each new problem must be a subtype of FieldProblem or BoundaryProblem. The main difference between these two are that FieldProblem is assembling local matrices for domain Omega whereas BoundaryProblem is creating (in general) constraint matrices for boundary Gamma_mathrmD. The general structure to solve in JuliaFEM is currently described by four different matrices and two vectors, i.e.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"beginbmatrix\nboldsymbolK  boldsymbolC_1\nboldsymbolC_2  boldsymbolD\nendbmatrix\nbeginbmatrix\nboldsymbolu\nboldsymbollambda\nendbmatrix =\nbeginbmatrix\nboldsymbolf\nboldsymbolg\nendbmatrix","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"We believe that this construction is general enough to describe all possible situations in future. Quite often boldsymbolC_1 = boldsymbolC_2^mathrmT and boldsymbolD = boldsymbol0 so that we have a typical saddle point problem","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"beginbmatrixboldsymbolK  boldsymbolC^mathrmT\nboldsymbolC  boldsymbol0\nendbmatrixbeginbmatrixboldsymbolu\nboldsymbollambda\nendbmatrix=beginbmatrixboldsymbolf\nboldsymbolg\nendbmatrix","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"which is equivalent to minimization problem","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"min_boldsymbolCboldsymbolu = boldsymbolg\nfrac12 boldsymbolu^mathrmT boldsymbolK boldsymbolu -\nboldsymbolu^mathrmT boldsymbolf","category":"page"},{"location":"problems/#Discretizing-field-problem-1","page":"Problems","title":"Discretizing field problem","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"So, first we must define a new type, e.g. Heat, which is a subclass of FieldProblem. Problem-wide parameters can be defined into struct if needed.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"type Heat <: FieldProblem\nend","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"In principle it's possible to assemble one element at a time, but way more memory efficient is to assemble all elements with same kind (basis) at same time and preallocate memory only one time before looping through element list. Implementation for assembling local stiffness matrix is","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"function assemble_elements!{B}(problem::Problem{Heat}, assembly::Assembly,\n                               elements::Vector{Element{B}}, time::Float64)\n\n    println(\"Assembling elements of kind $B\")\n    bi = BasisInfo(B)\n    ndofs = length(B)\n    Ke = zeros(ndofs, ndofs)\n\n    for element in elements\n        fill!(Ke, 0.0)\n        for ip in get_integration_points(element)\n            J, detJ, N, dN = element_info!(bi, element, ip, time)\n            k = element(\"thermal conductivity\", ip, time)\n            Ke += ip.weight * k*dN'*dN * detJ\n        end\n        gdofs = get_gdofs(problem, element)\n        add!(assembly.K, gdofs, gdofs, Ke)\n    end\n\nend\n\nnothing # hide","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Here, first some memory is allocated to calculate Jacobian, gradients etc. to BasisInfo. Ke is used to store local stiffness matrix. Then iterate over all elements and integration points, evaluate basis and add contribution to local stiffness matrix. Finally, get global degrees of freedom for element by using command get_gdofs and finally add contribution to global stiffness matrix K.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"From performance point of view, it's important that memory allocations inside at least the innermost loop is minimized, although assembling global stiffness matrix can be parallelized (at least almost) perfectly and is not considered as a bottleneck when models get big enough. It's anyway a good idea to pay attention to the memory allocations.","category":"page"},{"location":"problems/#Setting-and-getting-global-degrees-of-freedom-for-element-1","page":"Problems","title":"Setting and getting global degrees of freedom for element","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"get_gdofs is returning the global degrees of freedom for element. They can be set manually using set_gdofs(problem, element, dofs). Otherwise they are calculated automatically based on the problem dimension using formula g(i,j,d) = d*(i-1)+j, where i is local node number, j is the number of degree of freedom and d is the maximum number of degrees of freedom for node. With this formula dofs are ordered so that first comes all dofs for node 1, then for node 2 and so on. For 3 dofs/node we get (u_11 u_12 u_13 u_21 u_22 u_23 ldots u_N1 u_N2 u_N3), where the first index is node number and second index is dof number.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Let's create some test problem and test our implementation:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"el1 = Element(Quad4, [1, 2, 3, 4])\nX = Dict(1 => [0.0,0.0], 2 => [1.0,0.0], 3 => [1.0,1.0], 4 => [0.0,1.0])\nupdate!(el1, \"geometry\", X)\nupdate!(el1, \"thermal conductivity\", 6.0)\nelements = [el1]\nassembly = Assembly()\nproblem = Problem(Heat, \"test problem\", 1)\nnothing # hide","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Now the struct Heat is empty. If we need to store some problem-wide settings to that struct, they can be found from problem.properties. When creating a new Problem, the syntax is Problem(type, name, field_dimension), where two first arguments are self descriptive. The third one is the information, how many degrees of freedom is in this problem. As Poisson problem is scalar equation, there is only 1 degrees of freedom per node. For example in continuum mechanics, where the unknown field is displacement, there is usually 2-6 degrees of freedom per node, depending on problem type. Next we do the actual assembling of elements into global stiffness matrix:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"time = 0.0\nassemble_elements!(problem, assembly, elements, time)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"full(assembly.K)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"There is actually one Assembly inside Problem and elements are defined to problem using add_elements!, so a more realistic use case to create global assembly would be to use assemble!(problem, time) as shown below:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"el2 = Element(Tri3, [3, 2, 5])\nX[5] = [2.0, 1.0]\nelements = [el1, el2]\nupdate!(elements, \"geometry\", X)\nupdate!(elements, \"thermal conductivity\", 6.0)\nproblem = Problem(Heat, \"test problem\", 1)\nadd_elements!(problem, elements)\nassemble!(problem, time)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"full(problem.assembly.K)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Now, function defined above is actually executed two times, first for elements using Tri3 basis and after that for Quad4. That is, assemble!(problem, time) is grouping elements by their type and calling function for each element type separately. It also does some initializations and gives possibility to mangle matrices before and after assembly. These hacks may be useful if one needs to add some discrete values to the matrices after assembly or e.g. save matrices to disk for later diagnoses.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"We also need to deal with the integrals on the right hand side. The first integral is done over the domain and can be included to the same assemble_elements!-function than stiffness matrix. Boundary term can be handled in different ways. One option is to define it yet in same function and search for fields like surface traction S1, where S1 is one side of the element. This is how it is done in ABAQUS. Another way is to use lower dimensional \"boundary element\" in assembly and add surface term to that element. This is how it is done in Code Aster.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"assembly_elements!-function defined above can be overridden by restricting the type of elements list, elements::Vector{Element{B}} to a some spesific elements. This allows, for example, to optimize assembly for some certain element type what is commonly used. Another use case is to define different assembly function for boundary elements. In 2d setting, voluminal elements like Tet3, Tet6, Quad4, Quad8, Quad9 are integrated over volume and they one dimensional counterparts Seg2, Seg3 can be used to assign boundary fluxes.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"The updated assemble_elements!-function, which can also handle volume load from right hand side of the equation, i.e. ","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"int fvmathrmdx","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"looks like following:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"function assemble_elements!{B}(problem::Problem{Heat}, assembly::Assembly,\n                               elements::Vector{Element{B}}, time::Float64)\n\n    println(\"Assembling volume elements of kind $B\")\n    bi = BasisInfo(B)\n    ndofs = length(B)\n    Ke = zeros(ndofs, ndofs)\n    fe = zeros(ndofs)\n\n    for element in elements\n        fill!(Ke, 0.0)\n        fill!(fe, 0.0)\n        for ip in get_integration_points(element)\n            J, detJ, N, dN = element_info!(bi, element, ip, time)\n            k = element(\"thermal conductivity\", ip, time)\n            Ke += ip.weight * k*dN'*dN * detJ\n            if haskey(element, \"heat source\")\n                f = element(\"heat source\", ip, time)\n                fe += ip.weight * N'*f * detJ\n            end\n        end\n        gdofs = get_gdofs(problem, element)\n        add!(assembly.K, gdofs, gdofs, Ke)\n        add!(assembly.f, gdofs, fe)\n    end\n\nend\n\nnothing # hide","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"At last, implement boundary elements to handle heat flux. To choose what elements should use this assembly function, elements::Vector{Element{B}} must be restricted only to group where B<:Union{Seg2, Seg}.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"function assemble_elements!{B<:Union{Seg2,Seg3}}(problem::Problem{Heat},\n                                                 assembly::Assembly,\n                                                 elements::Vector{Element{B}},\n                                                 time::Float64)\n\n    println(\"Assembling boundary elements of kind $B\")\n    bi = BasisInfo(B)\n    ndofs = length(B)\n    fe = zeros(ndofs)\n\n    for element in elements\n        haskey(element, \"heat flux\") || continue\n        fill!(fe, 0.0)\n        for ip in get_integration_points(element)\n            J, detJ, N, dN = element_info!(bi, element, ip, time)\n            g = element(\"heat flux\", ip, time)\n            fe += ip.weight * N'*g * detJ\n        end\n        gdofs = get_gdofs(problem, element)\n        add!(assembly.f, gdofs, fe)\n    end\n\nend\n\nnothing # hide","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"To test everything implemented, create some small test problem:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"el1 = Element(Quad4, [1, 2, 3, 4])\nel2 = Element(Tri3, [3, 2, 5])\nel3 = Element(Seg2, [3, 5])\nX = Dict(1 => [0.0, 0.0],\n         2 => [1.0, 0.0],\n         3 => [1.0, 1.0],\n         4 => [0.0, 1.0],\n         5 => [2.0, 1.0])\nelements = [el1, el2, el3]\nupdate!(elements, \"geometry\", X)\nupdate!(elements, \"thermal conductivity\", 6.0)\nupdate!(el3, \"heat flux\", 264.0)\nupdate!(el1, \"heat source\", 132.0)\nproblem = Problem(Heat, \"test problem\", 1)\nadd_elements!(problem, elements)\nassemble!(problem, time)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Global stiffness matrix boldsymbolK and force vector boldsymbolf are","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"K = full(problem.assembly.K)\nf = full(problem.assembly.f)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"To get unique solution, some essential boundary condition must be given, e.g. set dofs 1 and 4 fixed, u_1 = u_4 = 0.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"u = zeros(5)\nall_dofs = collect(1:5)\nfixed_dofs = [1, 4]\nfree_dofs = setdiff(all_dofs, fixed_dofs)\nu[free_dofs] = K[free_dofs,free_dofs] \\ f[free_dofs]\nu","category":"page"},{"location":"problems/#Discretizing-boundary-problem-1","page":"Problems","title":"Discretizing boundary problem","text":"","category":"section"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Can be e.g. Dirichlet boundary, contact / mesh tie problem between two domains, BEM formulation, kinematic coupling (MPC) and so on.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"A good question is to determine how to map element local degrees of freedom with global ones. As the plan is to develop a multiphysical FEM platform, it's a hard question how to create this kind of mapping in a dynamic way. Yet another question is how to set boundary conditions for different type of physics. For now, these questions are answered by defining the name of unknown field using function get_unknown_field_name and giving the dimension of unknown field when creating a problem, so that change of information between two problem is possible. This solution has already identified shortcomings and can be expected to change in future.","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"function get_unknown_field_name(::Problem{Heat})\n    return \"temperature\"\nend\n\nnothing # hide","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"type DirichletBC <: BoundaryProblem\nend","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Our implementation to handle boundary condition u = u_0 looks following:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"function assemble_elements!{E}(problem::Problem{DirichletBC},\n                               assembly::Assembly,\n                               elements::Vector{Element{E}},\n                               time::Float64)\n\n    name = get_parent_field_name(problem)\n    dim = get_unknown_field_dimension(problem)\n\n    println(\"Assembling Dirichlet boundary condition\")\n    println(\"Field name = $name, dofs/node = $dim\")\n\n    data = Dict{Int64,Float64}()\n    for element in elements\n        for i=1:dim\n            haskey(element, \"$name $dim\") || continue\n            gdofs = get_gdofs(problem, element)\n            ldofs = gdofs[i:dim:end]\n            xis = get_reference_element_coordinates(E)\n            for (ldof, xi) in zip(ldofs, xis)\n                data[ldof] = interpolate(element, \"$name $dim\", xi, time)\n            end\n        end\n    end\n\n    for (dof, val) in data\n        add!(assembly.C1, dof, dof, 1.0)\n        add!(assembly.C2, dof, dof, 1.0)\n        add!(assembly.g, dof, val)\n    end\n\nend","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"To fix dofs 1 and 4 like before:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"bel1 = Element(Seg2, [1, 4])\nupdate!(bel1, \"geometry\", X)\nupdate!(bel1, \"temperature 1\", 0.0)\nbc = Problem(DirichletBC, \"fixed\", 1, \"temperature\")\nadd_elements!(bc, [bel1])\nassemble!(bc, time)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Now we have all matrices needed:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"C1 = full(bc.assembly.C1, 5, 5)\nC2 = full(bc.assembly.C2, 5, 5)\nD = full(bc.assembly.D, 5, 5)\ng = full(bc.assembly.g, 5, 1)","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Together with already calculated matrices, we can now form saddle point problem boldsymbolAboldsymbolx = boldsymbolb:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"A = [K C1; C2 D]\nb = [f; g]","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Solution:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"nz = [1, 2, 3, 4, 5, 6, 9]\nx = zeros(10)\nx[nz] = A[nz,nz] \\ b[nz]","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"As a result we have found boldsymbolu and boldsymbollambda:","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"u = x[1:5]\nla = x[6:10]\nu' * la","category":"page"},{"location":"problems/#","page":"Problems","title":"Problems","text":"Both field problem and boundary problems can of course have all four matrices and two vectors. For example, in finite sliding contact algorithms all four matrices are used as algorithms are contributing to stiffness matrix also when linearized properly.","category":"page"},{"location":"problems/#Assembling-mass-matrices-1","page":"Problems","title":"Assembling mass matrices","text":"","category":"section"},{"location":"problems/#Using-problem-wide-fields-1","page":"Problems","title":"Using problem-wide fields","text":"","category":"section"},{"location":"problems/#Discretizing-mixed-problems-1","page":"Problems","title":"Discretizing mixed problems","text":"","category":"section"},{"location":"problems/#Using-automatic-differentiation-to-linearize-non-linear-problem-1","page":"Problems","title":"Using automatic differentiation to linearize non-linear problem","text":"","category":"section"},{"location":"#FEMBase.jl-1","page":"Introduction","title":"FEMBase.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Package author: Jukka Aho (@ahojukka5, ahojukka5@gmail.com)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"FEMBase.jl is a base package for FEM codes. It implements all the basic data structures in an efficient way and aims to be the rock-solid backbone which can be used to build your very own FEM solver. The basis principle is that FEMBase is a tiny and well-optimized, efficient subset of larger finite element method software with pre- and postprocessors. FEMBase.jl is used in JuliaFEM.jl.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"In order to make a stable package, all operations that are not closely related to the basic operations are left out. This encourages to develop a highly modular FEM where features are implemented in their own packages. The stragegy chosen is intentional. Pre- and posprocessing, physical models, file formats and things like that evolve in time, while the basic principles stay. We want that those evolving things stay in their own packages as much as possible.","category":"page"},{"location":"#What-FEMBase.jl-does-1","page":"Introduction","title":"What FEMBase.jl does","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"FEMBase implements all kind of basic data types like Problem, Element, Node, IntegrationPoint, Analysis and so on so that user can define the discretized geometry and integration scheme. Each element does have a topology like Poi1, Seg2, Tri3, Quad4, Tet4, Hex8 for isoparametric linear elements having only corner nodes or Seg3, Tri6, Quad8, Tet10, Hex20 for isoparametric quadratic elements having nodes in middle of the edges. Then there is also elements having middle nodes like Tri7 and Quad9.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Data of model is repsented in fields. Data type can be scalar, vector, tensor or something user-defined for spesific needs. Data can be defined in analysis, problem, element, node or integration point. Data can depend on time and it can be interpolated with respect to time using different interpolation schemes.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Data can also be interpolated in spatial direction using basis functions, which are Lagrange basis functions at the moment.","category":"page"},{"location":"#What-FEMBase.jl-doesn't-do-1","page":"Introduction","title":"What FEMBase.jl doesn't do","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"FEMBase.jl doesn't solve the system of equations. You can define model and data, integrate and interpolate, but you need to write your own solver. And as a consequence it doesn't write the results to anywhere, so you need to implement your own results writer or use some of the existing solutions like XdmfWriter.jl.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"FEMBase.jl doesn't have any physical models. FEMBase doesn't know anything about displacements, temperatures, velocities or pressures. FEMBase.jl does assemble a problem, but it doesn't define it. So you need to build your physical model in some other package or use some of the existing solutions like HeatTransfer.jl. Things related to geometry, like calculating Jacobians, are supported.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"FEMBase does not parse mesh from other format. For that, you need to implement your own parser or use some existing solutions, like AbaqusReader.jl, AsterReader.jl or Gmsh.jl.","category":"page"},{"location":"#What-FEMBase.jl-is-planning-to-do-1","page":"Introduction","title":"What FEMBase.jl is planning to do","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Given data and basis functions, we should be able to naturally interpolate any kind of data. In current implementation, we have an assumption that data is defined in nodes like it is done standard FE methods. Then we have things like hierarchical elements, NURBS, material particle method and so on, which should also be possible to implement using FEMBase.","category":"page"},{"location":"#Nomenclature-1","page":"Introduction","title":"Nomenclature","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"In this package, the roof concept is analysis, which can mean any kind of action done given a set of problems. We analyze a problem. Analysis can be, for example, integrating the volume of some area, calculating the pressure, temperature or displacement of some volume, calculating it's eigenvalues or things like that. In even highler level, a simulation is a sequence of analyses performed in order to achieve of final deliverable. In commercial softwares, analysis would resemble maybe like \"STEP\" in ABAQUS.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The subject of analysis doesn't have to be anything what we physically observe, like a solid volume. In abstract sense, it's just a set of problems to where we apply a series of actions. At this level of abstraction, we don't care about the internal structure of the problem. So what are then the problems?","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Each analysis is having a set of problems. There can be only one or there can be several. One could think \"problem\" something equivalent to \"body\" in some other FEM codes, or something similar, byt it's not physically restricted in any manner. Problem describes the physics, what is considered to be solved. The reason why problems are not called to bodies in FEMBase is the following: not all problems relates to the volume.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"For example, when elastic bodies are having surface interactions, it's called to contact problem, and the problem can be fully described just by knowing the boundary / surface of the bodies. In the final discretized system, we do not need any information about the internal structure of the volume. Thus it would be unnecessary complication to carry all that data with the problem.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"In problem level, we need to start thinking about how we describe it. In the context of finite elements, we are describing the problem with the help of finite elements. And in this level, we need to take care of our solution strategy. Discretized problem has to be somehow transferred to something what linear system solver understands. So, the problem is kind of \"element set\". Problem have a matrix level representation and elements describing the problem. This is the level where new physical rules are applied. Given a set of elements, populate the matrices ready for solver.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"For this, we need to have some mapping, which connect each element local degrees of freedom to the global ones.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The element itself is an individual entity. It doesn't need anything surrounding complexity to fully describe it's own state. It can be connected to problem, but it's not mandatory. Element is having it's own topology, basis functions and fields. Element doesn't even need a connection information to other elements. Element needs to know only it's own geometry. Given basis and data, element can interpolate its results in the geometrical domain occupied by that element. Element can form it own local matrices. Your own one element FEM should be possible to do just by using Element, without any complexities.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"When doing FEM, we also need to integrate, which is done numerically using some discrete integration scheme. Thus we need integation points. They are defined inside elements.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"analysis -> problems -> elements -> integration points","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"In this description, we did go in top-down-approach. This same setup should also make sense when going in other direction.","category":"page"},{"location":"#Outline-1","page":"Introduction","title":"Outline","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This documentation aims to describe the structures of the package in \"bottom to up\" manner. starting from the smaller data types proceeding to the big scope.","category":"page"}]
}
