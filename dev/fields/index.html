<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fields · FEMBase.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83590644-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FEMBase.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Fields</a><ul class="internal"><li><a class="tocitem" href="#Creating-new-fields-1"><span>Creating new fields</span></a></li><li><a class="tocitem" href="#Dicrete,-constant,-time-invariant-field-(DCTI)-1"><span>Dicrete, constant, time invariant field (DCTI)</span></a></li><li><a class="tocitem" href="#Dicrete,-variable,-time-invariant-fields-(DVTI)-1"><span>Dicrete, variable, time invariant fields (DVTI)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Fields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fields</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFEM/FEMBase.jl/blob/master/test/test_fields.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia">using FEMBase, Test</code></pre><p>From the beginning of a project we had a clear concept in our mind: &quot;everything is a field&quot;. That is, everything can vary temporally and spatially. We think that constant is just a special case of field which does not vary in temporal nor spatial direction. Fields can vary in spatial direction, i.e. can be either constant or variable, and in temporal direction, i.e. can be time variant or time invariant. From this pondering we can think that there exists four kind of (discrete) fields:</p><ul><li>discrete, constant, time invariant (DCTI)</li><li>discrete, variable, time invariant (DVTI)</li><li>discrete, constant, time variant (DCTV)</li><li>discrete, variable, time variant (DVTV)</li></ul><p>Discrete, in this context, means that field is defined in point-wise in <span>$1 \ldots n$</span> locations, from where it is then interpolated to whole domain using some interpolation polynomials, i.e.</p><div>\[u(\xi, t) = \sum_{i} u_i[t] N_{i}(\xi,t),\]</div><p>math where     <span>$N_{i}(\xi, t)$</span> is the basis function or interpolation polymial corresponding to <span>$i$</span>^{th} discrete value and     <span>$u_{i}$</span> is the discrete value.</p><p>Then we have continuous fields, which are defined in whole domain, or at least not point-wise. By following the already used abbreviations, we have four more fields:</p><ul><li>continuous, constant, time invariant (CCTI)</li><li>continuous, variable, time invariant (CVTI)</li><li>continuous, constant, time variant (DCTV)</li><li>continuous, variable, time variant (CVTV)</li></ul><p>Continuous, again in this context, does not mean that field has to be defined everywhere. It&#39;s enough that it&#39;s defined in function of spatial and/or temporal coordinates, i.e. we have <span>$u \equiv u(\xi, t)$</span>, without a some spesific basis needed to interpolate from discrete values.</p><p>Field itself can be in principle anything. However, usually either scalar, vector or tensor (matrix). Time does not to have be real, it can be for example angle of some rotating machine or even complex value.</p><p>From these starting points, we assume that the mentioned field system can describe all imaginable situations.</p><h2 id="Creating-new-fields-1"><a class="docs-heading-anchor" href="#Creating-new-fields-1">Creating new fields</a><a class="docs-heading-anchor-permalink" href="#Creating-new-fields-1" title="Permalink"></a></h2><p>For discrete fields that are varying in spatial direction, value for each discrete point is defined using NTuple. The order of points is implicitly assumed to be same than node ordering in ABAQUS. That is, first corner nodes in anti-clockwise direction and after that middle nodes.</p><p>For example, <code>(1, 2, 3, 4)</code> is a scalar field having length of 4 and <code>([1,2],[2,3],[3,4],[4,5])</code> is a vector field having length of 4.</p><p>For fields that are varying in temporal direction, <code>time =&gt; value</code> syntax is used. The first item in pair is time (or similar) and second item is value assigned to that time. For example, <code>0.0 =&gt; 1.0</code> is a time-dependent scalar field having value 1.0 at time 0.0.</p><h2 id="Dicrete,-constant,-time-invariant-field-(DCTI)-1"><a class="docs-heading-anchor" href="#Dicrete,-constant,-time-invariant-field-(DCTI)-1">Dicrete, constant, time invariant field (DCTI)</a><a class="docs-heading-anchor-permalink" href="#Dicrete,-constant,-time-invariant-field-(DCTI)-1" title="Permalink"></a></h2><p>The most simple field is a field that is constant in both time and spatial direction. Discrete, constant, time invariant field. For example, youngs modulus could be this kind of field.</p><pre><code class="language-julia">a = DCTI(1)</code></pre><pre><code class="language-none">DCTI{Int64}(1)</code></pre><p>Accessing data is done using <code>interpolate</code>. In FEM codes, we try to hide the actual type of the field, so for example interpolating constant field works, but the result is quite unsuprising.</p><pre><code class="language-julia">@test interpolate(a, 0.0) == 1</code></pre><pre><code class="language-none">Test Passed</code></pre><p>Field value value can be updated with <code>update!</code> function:</p><pre><code class="language-julia">update!(a, 2)
@test a == 2</code></pre><pre><code class="language-none">Test Passed</code></pre><p>Constant field of course doesn&#39;t have to be scalar field. It can be e.g. vector field. I use here packate Tensors.jl because of its excellent performance and other features, but normal <code>Vector</code> would work just fine also:</p><pre><code class="language-julia">using Tensors

b = DCTI(Vec(1, 2))</code></pre><pre><code class="language-none">DCTI{Tensors.Tensor{1,2,Int64,2}}([1, 2])</code></pre><p>Interpolation, again, returns just the original data:</p><pre><code class="language-julia">@test interpolate(b, 0.0) == [1, 2]</code></pre><pre><code class="language-none">Test Passed</code></pre><p>Updating field is done using <code>update!</code>-function:</p><pre><code class="language-julia">update!(b, Vec(2, 3))
@test interpolate(b, 0.0) == [2, 3]</code></pre><pre><code class="language-none">Test Passed</code></pre><p>Constant tensor field:</p><pre><code class="language-julia">c = DCTI(Tensor{2,2}((1.0, 2.0, 3.0, 4.0)))</code></pre><pre><code class="language-none">DCTI{Tensors.Tensor{2,2,Float64,4}}([1.0 3.0; 2.0 4.0])</code></pre><p>Data can be accessed also using <code>getindex</code>. Also things like <code>length</code> and <code>size</code> are defined.</p><pre><code class="language-julia">@test interpolate(c, 0.0) == [1 3; 2 4]
@test c[1] == [1 3; 2 4]
@test length(c) == 4
@test size(c) == (2, 2)</code></pre><pre><code class="language-none">Test Passed</code></pre><p>For now everything might look like extra complexity, but later on we see how to combine field with some basis functions in order to interpolate in element domain. Another nice feature is that we can interpolate fields in time. In this particular case of time invariant fields it of course doesn&#39;t give anything extra.</p><h2 id="Dicrete,-variable,-time-invariant-fields-(DVTI)-1"><a class="docs-heading-anchor" href="#Dicrete,-variable,-time-invariant-fields-(DVTI)-1">Dicrete, variable, time invariant fields (DVTI)</a><a class="docs-heading-anchor-permalink" href="#Dicrete,-variable,-time-invariant-fields-(DVTI)-1" title="Permalink"></a></h2><pre><code class="language-">@testset &quot;DVTI field&quot; begin</code></pre><p>scalar field</p><pre><code class="language-julia">    a = DVTI((1, 2))
    @test a[1] == 1
    @test a[2] == 2
    @test interpolate(a, 0.0) == (1, 2)
    update!(a, (2, 3))
    @test a == (2, 3)
    @test (2, 3) == a</code></pre><pre><code class="language-none">Test Passed</code></pre><p>vector field</p><pre><code class="language-julia">    b = DVTI(([1, 2], [2, 3]))
    @test b[1] == [1, 2]
    @test b[2] == [2, 3]
    @test interpolate(b, 0.0) == ([1, 2], [2, 3])
    update!(b, ([2, 3], [4, 5]))
    @test b == ([2, 3], [4, 5])</code></pre><pre><code class="language-none">Test Passed</code></pre><p>tensor field</p><pre><code class="language-julia">    c = DVTI(([1 2; 3 4], [2 3; 4 5]))
    @test c[1] == [1 2; 3 4]
    @test c[2] == [2 3; 4 5]
    @test interpolate(c, 0.0) == ([1 2; 3 4], [2 3; 4 5])
    update!(c, ([2 3; 4 5], [5 6; 7 8]))
    @test c == ([2 3; 4 5], [5 6; 7 8])

    d = DVTI(2, 3)
    @test a == d
end

@testset &quot;DCTV field&quot; begin</code></pre><pre><code class="language-none">Test Passed</code></pre><p>scalar field</p><pre><code class="language-julia">    a = DCTV(0.0 =&gt; 0.0, 1.0 =&gt; 1.0)
    @test isapprox(interpolate(a, -1.0), 0.0)
    @test isapprox(interpolate(a, 0.0), 0.0)
    @test isapprox(interpolate(a, 0.5), 0.5)
    @test isapprox(interpolate(a, 1.0), 1.0)
    update!(a, 1.0 =&gt; 2.0)
    @test isapprox(interpolate(a, 0.5), 1.0)
    update!(a, 2.0 =&gt; 1.0)
    @test isapprox(interpolate(a, 1.5), 1.5)</code></pre><pre><code class="language-none">Test Passed</code></pre><p>vector field</p><pre><code class="language-julia">    b = DCTV(0.0 =&gt; [1.0, 2.0], 1.0 =&gt; [2.0, 3.0])
    @test isapprox(interpolate(b, 0.5), [1.5, 2.5])</code></pre><pre><code class="language-none">Test Passed</code></pre><p>tensor field</p><pre><code class="language-julia">    c = DCTV(0.0 =&gt; [1.0 2.0; 3.0 4.0], 1.0 =&gt; [2.0 3.0; 4.0 5.0])
    @test isapprox(interpolate(c, 0.5), [1.5 2.5; 3.5 4.5])
end

@testset &quot;DVTV field&quot; begin</code></pre><pre><code class="language-none">Test Passed</code></pre><p>scalar field</p><pre><code class="language-julia">    a = DVTV(0.0 =&gt; (0.0, 1.0), 1.0 =&gt; (1.0, 0.0))
    update!(a, 2.0 =&gt; (2.0, 0.0))
    r = interpolate(a, 0.5)
    @test isapprox(r[1], 0.5)
    @test isapprox(r[2], 0.5)
    update!(a, 2.0 =&gt; (4.0, 0.0))
end

@testset &quot;CVTV field&quot; begin
    f = CVTV((xi, t) -&gt; xi[1] * xi[2] * t)
    @test isapprox(f([1.0, 2.0], 3.0), 6.0)
end

@testset &quot;Dictionary fields&quot; begin
    X = Dict(1 =&gt; [0.0, 0.0], 1000 =&gt; [1.0, 0.0], 100000 =&gt; [1.0, 1.0])
    G = DVTId(X)
    @test isapprox(G[1], X[1])
    @test isapprox(G[1000], X[1000])
    @test isapprox(G[100000], X[100000])
    Y = Dict(1 =&gt; [2.0, 2.0], 1000 =&gt; [3.0, 2.0], 100000 =&gt; [3.0, 3.0])
    F = DVTVd(0.0 =&gt; X, 1.0 =&gt; Y)
    @test isapprox(interpolate(F, 0.5)[100000], [2.0, 2.0])
end

@testset &quot;update dictionary field&quot; begin
    f1 = Dict(1 =&gt; 1.0, 2 =&gt; 2.0, 3 =&gt; 3.0)
    f2 = Dict(1 =&gt; 2.0, 2 =&gt; 3.0, 3 =&gt; 4.0)
    fld = DVTVd(0.0 =&gt; f1)
    update!(fld, 1.0 =&gt; f2)
    @test isapprox(interpolate(fld, 0.5)[1], 1.5)
    update!(fld, 1.0 =&gt; f1)
    @test isapprox(interpolate(fld, 0.5)[1], 1.0)
end

@testset &quot;use of common constructor field&quot; begin
    @test isa(field(1.0), DCTI)
    @test isa(field(1.0 =&gt; 1.0), DCTV)
    @test isa(field((1.0, 2.0)), DVTI)
    @test isa(field(1, 2), DVTI)
    @test isa(field(1.0 =&gt; (1.0, 2.0)), DVTV)
    @test isa(field((xi, t) -&gt; xi[1] * t), CVTV)
    @test isa(field(1 =&gt; [1.0, 2.0], 10 =&gt; [2.0, 3.0]), DVTId)
    @test isa(field(0.0 =&gt; (1 =&gt; 1.0, 10 =&gt; 2.0), 1.0 =&gt; (1 =&gt; 2.0, 10 =&gt; 3.0)), DVTVd)
    X = Dict(1 =&gt; [0.0, 0.0], 2 =&gt; [1.0, 0.0])
    X1 = field(X)
    X2 = field(0.0 =&gt; X)
    @test isa(X1, DVTId)
    @test isa(X2, DVTVd)
end

@testset &quot;general interpolation&quot; begin
    a = [1, 2, 3]
    b = (2, 3, 4)
    @test interpolate(a, b) == 2 + 6 + 12
    a = (1, 2)
    b = (2, 3, 4)
    @test interpolate(a, b) == 2 + 6
    @test_throws AssertionError interpolate(b, a)
end</code></pre><pre><code class="language-none">2.0 =&gt; (4.0, 0.0)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 4 May 2020 14:03">Monday 4 May 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
